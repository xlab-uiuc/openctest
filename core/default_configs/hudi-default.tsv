hoodie.file.index.enable	true	Enables use of the spark file index implementation for Hudi, that speeds up listing of large tables.
hoodie.datasource.read.paths	N/A	Comma separated list of file paths to read within a Hudi table.
hoodie.datasource.read.incr.filters	(Optional)	For use-cases like DeltaStreamer which reads from Hoodie Incremental table and applies opaque map functions, filters appearing late in the sequence of transformations cannot be automatically pushed down. This option allows setting filters directly on Hoodie Source.
hoodie.enable.data.skipping	false	Enables data-skipping allowing queries to leverage indexes to reduce the search space by skipping over files
as.of.instant	N/A	The query instant for time travel. Without specified this option, we query the latest snapshot.
hoodie.datasource.read.schema.use.end.instanttime	false	Uses end instant schema when incrementally fetched data to. Default: users latest instant schema.
hoodie.datasource.read.incr.path.glob	(Optional)	For the use-cases like users only want to incremental pull from certain partitions instead of the full table. This option allows using glob pattern to directly filter on path.
hoodie.datasource.read.end.instanttime	N/A	Instant time to limit incrementally fetched data to. New data written with an instant_time <= END_INSTANTTIME are fetched out.
hoodie.datasource.write.precombine.field	ts	Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)
hoodie.datasource.merge.type	payload_combine	For Snapshot query on merge on read table, control whether we invoke the record payload implementation to merge (payload_combine) or skip merging altogetherskip_merge
hoodie.datasource.read.extract.partition.values.from.path	false	When set to true, values for partition columns (partition values) will be extracted from physical partition path (default Spark behavior). When set to false partition values will be read from the data file (in Hudi partition columns are persisted by default). This config is a fallback allowing to preserve existing behavior, and should not be used otherwise.
hoodie.schema.on.read.enable	false	Enables support for Schema Evolution feature
hoodie.datasource.read.begin.instanttime	N/A	Instant time to start incrementally pulling data from. The instanttime here need not necessarily correspond to an instant on the timeline. New data written with an instant_time > BEGIN_INSTANTTIME are fetched out. For e.g: â20170901080000â will get all new data written after Sep 1, 2017 08:00AM.
hoodie.datasource.read.incr.fallback.fulltablescan.enable	false	When doing an incremental query whether we should fall back to full table scans if file does not exist.
hoodie.datasource.query.type	snapshot	Whether data needs to be read, in incremental mode (new data since an instantTime) (or) Read Optimized mode (obtain latest view, based on base files) (or) Snapshot mode (obtain latest view, by merging base and (if any) log files)
hoodie.clustering.async.enabled	false	Enable running of clustering service, asynchronously as inserts happen on the table.
hoodie.datasource.write.operation	upsert	Whether to do upsert, insert or bulkinsert for the write operation. Use bulkinsert to load new data into a table, and there on use upsert/insert. bulk insert uses a disk based write path to scale to load large inputs without need to cache it.
hoodie.datasource.write.reconcile.schema	false	When a new batch of write has records with old schema, but latest table schema got evolved, this config will upgrade the records to leverage latest table schema(default values will be injected to missing fields). If not, the write batch would fail.
hoodie.datasource.write.recordkey.field	uuid	Record key field. Value to be used as the  component of . Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg:
hoodie.datasource.hive_sync.skip_ro_suffix	false	Skip the _ro suffix for Read optimized table, when registering
hoodie.datasource.write.partitionpath.urlencode	false	Should we url encode the partition path value, before creating the folder structure.
hoodie.datasource.hive_sync.partition_extractor_class	org.apache.hudi.hive.MultiPartKeysValueExtractor	Class which implements PartitionValueExtractor to extract the partition values, default 'org.apache.hudi.hive.MultiPartKeysValueExtractor'.
hoodie.datasource.hive_sync.serde_properties	N/A	Serde properties to hive table.
hoodie.datasource.hive_sync.sync_comment	false	Whether to sync the table column comments while syncing the table.
hoodie.datasource.hive_sync.password	hive	hive password to use
hoodie.datasource.write.keygenerator.consistent.logical.timestamp.enabled	false	When set to true, consistent value will be generated for a logical timestamp type column, like timestamp-millis and timestamp-micros, irrespective of whether row-writer is enabled. Disabled by default so as not to break the pipeline that deploy either fully row-writer path or non row-writer path. For example, if it is kept disabled then record key of timestamp type with value  will be written as timestamp  in row-writer path, while it will be written as long value  in non row-writer path. If enabled, then the timestamp value will be written in both the cases.
hoodie.datasource.hive_sync.support_timestamp	false	âINT64â with original type TIMESTAMP_MICROS is converted to hive âtimestampâ type. Disabled by default for backward compatibility.
hoodie.datasource.hive_sync.create_managed_table	false	Whether to sync the table as managed table.
hoodie.clustering.inline	false	Turn on inline clustering - clustering will be run after each write operation is complete
hoodie.datasource.compaction.async.enable	true	Controls whether async compaction should be turned on for MOR table writing.
hoodie.datasource.meta.sync.enable	false	Enable Syncing the Hudi Table with an external meta store or data catalog.
hoodie.datasource.write.streaming.ignore.failed.batch	true	Config to indicate whether to ignore any non exception error (e.g. writestatus error) within a streaming microbatch
hoodie.datasource.write.precombine.field	ts	Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)
hoodie.datasource.hive_sync.username	hive	hive user name to use
hoodie.datasource.write.partitionpath.field	N/A	Partition path field. Value to be used at the partitionPath component of HoodieKey. Actual value ontained by invoking .toString()
hoodie.datasource.write.streaming.retry.count	3	Config to indicate how many times streaming job should retry for a failed micro batch.
hoodie.datasource.hive_sync.partition_fields	(Optional)	Field in the table to use for determining hive partition columns.
hoodie.datasource.hive_sync.sync_as_datasource  true
hoodie.sql.insert.mode	upsert	Insert mode when insert data to pk-table. The optional modes are: upsert, strict and non-strict.For upsert mode, insert statement do the upsert operation for the pk-table which will update the duplicate record.For strict mode, insert statement will keep the primary key uniqueness constraint which do not allow duplicate record.While for non-strict mode, hudi just do the insert operation for the pk-table.
hoodie.datasource.hive_sync.use_jdbc	true	Use JDBC when hive synchronization is enabled
hoodie.meta.sync.client.tool.class	org.apache.hudi.hive.HiveSyncTool	Sync tool class name used to sync to metastore. Defaults to Hive.
hoodie.datasource.write.keygenerator.class	org.apache.hudi.keygen.SimpleKeyGenerator	Key generator class, that implements
hoodie.datasource.write.payload.class	org.apache.hudi.common.model.OverwriteWithLatestAvroPayload	Payload class used. Override this, if you like to roll your own merge logic, when upserting/inserting. This will render any value set for PRECOMBINE_FIELD_OPT_VAL in-effective
hoodie.datasource.hive_sync.table_properties	N/A	Additional properties to store with table.
hoodie.datasource.hive_sync.jdbcurl	jdbc:hive2://localhost:10000	Hive metastore url
hoodie.datasource.hive_sync.batch_num	1000	The number of partitions one batch when synchronous partitions to hive.
hoodie.datasource.hive_sync.assume_date_partitioning	false	Assume partitioning is yyyy/MM/dd
hoodie.datasource.hive_sync.bucket_sync	false	Whether sync hive metastore bucket specification when using bucket index.The specification is 'CLUSTERED BY (trace_id) SORTED BY (trace_id ASC) INTO 65536 BUCKETS'
hoodie.datasource.hive_sync.auto_create_database	true	Auto create hive database if does not exists
hoodie.datasource.hive_sync.database	default	The name of the destination database that we should sync the hudi table to.
hoodie.datasource.write.streaming.retry.interval.ms	2000	Config to indicate how long (by millisecond) before a retry should issued for failed microbatch
hoodie.sql.bulk.insert.enable	false	When set to true, the sql insert statement will use bulk insert.
hoodie.datasource.write.commitmeta.key.prefix	_	Option keys beginning with this prefix, are automatically added to the commit/deltacommit metadata. This is useful to store checkpointing information, in a consistent way with the hudi timeline
hoodie.datasource.write.drop.partition.columns	false	When set to true, will not write the partition columns into hudi. By default, false.
hoodie.datasource.hive_sync.enable	false	When set to true, register/sync the table to Apache Hive metastore.
hoodie.datasource.hive_sync.table	unknown	The name of the destination table that we should sync the hudi table to.
hoodie.datasource.hive_sync.ignore_exceptions	false	Ignore exceptions when syncing with Hive.
hoodie.datasource.hive_sync.use_pre_apache_input_format	false	Flag to choose InputFormat under com.uber.hoodie package instead of org.apache.hudi package. Use this when you are in the process of migrating from com.uber.hoodie to org.apache.hudi. Stop using this after you migrated the table definition to org.apache.hudi input format
hoodie.datasource.write.table.type	COPY_ON_WRITE	The table type for the underlying data, for this write. This canât change between writes.
hoodie.datasource.write.row.writer.enable	true	When set to true, will perform write operations directly using the spark native  representation, avoiding any additional conversion costs.
hoodie.datasource.write.hive_style_partitioning	false	Flag to indicate whether to use Hive style partitioning. If set true, the names of partition folders follow <partition_column_name>=<partition_value> format. By default false (the names of partition folders are only partition values)
hoodie.datasource.meta_sync.condition.sync	false	If true, only sync on conditions like schema change or partition change.
hoodie.datasource.hive_sync.mode	N/A	Mode to choose for Hive ops. Valid values are hms, jdbc and hiveql.
hoodie.datasource.write.table.name	N/A	Table name for the datasource write. Also used to register the table into meta stores.
hoodie.datasource.hive_sync.base_file_format	PARQUET	Base file format for the sync.
hoodie.deltastreamer.source.kafka.value.deserializer.class	io.confluent.kafka.serializers.KafkaAvroDeserializer	This class is used by kafka client to deserialize the records
hoodie.datasource.hive_sync.metastore.uris	thrift://localhost:9083	Hive metastore url
hoodie.datasource.write.insert.drop.duplicates	false	If set to true, filters out all duplicate records from incoming dataframe, during insert operations.
hoodie.datasource.write.partitions.to.delete	N/A	Comma separated list of partitions to delete
hoodie.precommit.validators.single.value.sql.queries	(Optional)	Spark SQL queries to run on table before committing new data to validate state after commit.Multiple queries separated by ';' delimiter are supported.Expected result is included as part of query separated by '#'. Example query: 'query1#result1:query2#result2'Note \<TABLE_NAME> variable is expected to be present in query.
hoodie.precommit.validators.equality.sql.queries	(Optional)	Spark SQL queries to run on table before committing new data to validate state before and after commit. Multiple queries separated by ';' delimiter are supported. Example: "select count(*) from \<TABLE_NAME> Note \<TABLE_NAME> is replaced by table state before and after commit.
hoodie.precommit.validators	(Optional)	Comma separated list of class names that can be invoked to validate commit
hoodie.precommit.validators.inequality.sql.queries	(Optional)	Spark SQL queries to run on table before committing new data to validate state before and after commit.Multiple queries separated by ';' delimiter are supported.Example query: 'select count(*) from \<TABLE_NAME> where col=null'Note \<TABLE_NAME> variable is expected to be present in query.
compaction.trigger.strategy	num_commits	Strategy to trigger compaction, options are 'num_commits': trigger compaction when reach N delta commits; 'time_elapsed': trigger compaction when time elapsed > N seconds since last compaction; 'num_and_time': trigger compaction when both NUM_COMMITS and TIME_ELAPSED are satisfied; 'num_or_time': trigger compaction when NUM_COMMITS or TIME_ELAPSED is satisfied. Default is 'num_commits'
index.state.ttl	0.0	Index state ttl in days, default stores the index permanently
hive_sync.serde_properties	N/A	Serde properties to hive table, the data format is k1=v1 k2=v2
hive_sync.table	unknown	Table name for hive sync, default 'unknown'
write.payload.class	org.apache.hudi.common.model.OverwriteWithLatestAvroPayload	Payload class used. Override this, if you like to roll your own merge logic, when upserting/inserting. This will render any value set for the option in-effective
compaction.tasks	4	Parallelism of tasks that do actual compaction, default is 4
hoodie.datasource.write.hive_style_partitioning	false	Whether to use Hive style partitioning. If set true, the names of partition folders follow <partition_column_name>=<partition_value> format. By default false (the names of partition folders are only partition values)
table.type	COPY_ON_WRITE	Type of table to write. COPY_ON_WRITE (or) MERGE_ON_READ
hive_sync.auto_create_db	true	Auto create hive database if it does not exists, default true
compaction.timeout.seconds	1200	Max timeout time in seconds for online compaction to rollback, default 20 minutes
hive_sync.username	hive	Username for hive sync, default 'hive'
write.sort.memory	128	Sort memory in MB, default 128MB
write.bulk_insert.shuffle_input	true	Whether to shuffle the inputs by specific fields for bulk insert tasks, default true
write.retry.times	3	Flag to indicate how many times streaming job should retry for a failed checkpoint batch. By default 3
metadata.enabled	false	Enable the internal metadata table which serves table metadata like level file listings, default disabled
write.parquet.max.file.size	120	Target size for parquet files produced by Hudi write phases. For DFS, this needs to be aligned with the underlying filesystem block size for optimal performance.
clustering.plan.strategy.daybased.skipfromlatest.partitions	0	Number of partitions to skip from latest when choosing partitions to create ClusteringPlan
hoodie.bucket.index.hash.field	(Optional)	Index key field. Value to be used as hashing to find the bucket ID. Should be a subset of or equal to the recordKey fields. Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg:
hoodie.bucket.index.num.buckets	4	Hudi bucket number per partition. Only affected if using Hudi bucket index.
hive_sync.mode	jdbc	Mode to choose for Hive ops. Valid values are hms, jdbc and hiveql, default 'jdbc'
write.retry.interval.ms	2000	Flag to indicate how long (by millisecond) before a retry should issued for failed checkpoint batch. By default 2000 and it will be doubled by every retry
write.partition.format	N/A	Partition path format, only valid when 'write.datetime.partitioning' is true, default is: 1) 'yyyyMMddHH' for timestamp(3) WITHOUT TIME ZONE, LONG, FLOAT, DOUBLE, DECIMAL; 2) 'yyyyMMdd' for DATE and INT.
clustering.async.enabled	false	Async Clustering, default false
clustering.plan.partition.filter.mode	NONE	Partition filter mode used in the creation of clustering plan. Available values are - NONE: do not filter table partition and thus the clustering plan will include all partitions that have clustering candidate.RECENT_DAYS: keep a continuous range of partitions, worked together with configs 'hoodie.clustering.plan.strategy.daybased.lookback.partitions' and 'hoodie.clustering.plan.strategy.daybased.skipfromlatest.partitions.SELECTED_PARTITIONS: keep partitions that are in the specified range ['hoodie.clustering.plan.strategy.cluster.begin.partition', 'hoodie.clustering.plan.strategy.cluster.end.partition'].
hive_sync.db	default	Database name for hive sync, default 'default'
clustering.plan.strategy.sort.columns	(Optional)	Columns to sort the data by when clustering
compaction.schedule.enabled	true	Schedule the compaction plan, enabled by default for MOR
hive_sync.partition_extractor_class	org.apache.hudi.hive.SlashEncodedDayPartitionValueExtractor	Tool to extract the partition value from HDFS path, default 'SlashEncodedDayPartitionValueExtractor'
write.precombine	false	Flag to indicate whether to drop duplicates before insert/upsert. By default these cases will accept duplicates, to gain extra performance: 1) insert operation; 2) upsert for MOR table, the MOR table deduplicate on reading
write.batch.size	256.0	Batch buffer size in MB to flush data into the underneath filesystem, default 256MB
hoodie.datasource.write.keygenerator.class	N/A	Key generator class, that implements will extract the key out of incoming record
index.global.enabled	true	Whether to update index for the old partition path if same key record with different partition path came in, default true
clustering.delta_commits	4	Max delta commits needed to trigger clustering, default 4 commits
path	N/A	Base path for the target hoodie table. The path would be created if it does not exist, otherwise a Hoodie table expects to be initialized successfully
index.bootstrap.enabled	false	Whether to bootstrap the index state from existing hoodie table, default false
read.streaming.skip_compaction	false	Whether to skip compaction instants for streaming read, there are two cases that this option can be used to avoid reading duplicates: 1) you are definitely sure that the consumer reads faster than any compaction instants, usually with delta time compaction strategy that is long enough, for e.g, one week; 2) changelog mode is enabled, this option is a solution to keep data integrity
compaction.async.enabled	true	Async Compaction, enabled by default for MOR
hive_sync.ignore_exceptions	false	Ignore exceptions during hive synchronization, default false
hive_sync.table_properties	N/A	Additional properties to store with table, the data format is k1=v1 k2=v2
write.ignore.failed	true	Flag to indicate whether to ignore any non exception error (e.g. writestatus error). within a checkpoint batch. By default true (in favor of streaming progressing over data integrity)
write.commit.ack.timeout	-1	Timeout limit for a writer task after it finishes a checkpoint and waits for the instant commit success, only for internal use
write.operation	upsert	The write operation, that this write should do
hoodie.datasource.write.partitionpath.field	(Optional)	Partition path field. Value to be used at the  component of . Actual value obtained by invoking .toString(), default ''
write.bucket_assign.tasks	N/A	Parallelism of tasks that do bucket assign, default is the parallelism of the execution environment
compaction.delta_commits	5	Max delta commits needed to trigger compaction, default 5 commits
partition.default_name	HIVE_DEFAULT_PARTITION	The default partition name in case the dynamic partition column value is null/empty string
write.bulk_insert.sort_input	true	Whether to sort the inputs by specific fields for bulk insert tasks, default true
clustering.plan.strategy.small.file.limit	600	Files smaller than the size specified here are candidates for clustering, default 600 MB
clustering.schedule.enabled	false	Schedule the cluster plan, default false
compaction.target_io	512000	Target IO in MB for per compaction (both read and write), default 500 GB
clustering.plan.strategy.class	org.apache.hudi.client.clustering.plan.strategy.FlinkSizeBasedClusteringPlanStrategy	Config to provide a strategy class (subclass of ClusteringPlanStrategy) to create clustering plan i.e select what file groups are being clustered. Default strategy, looks at the last N (determined by clustering.plan.strategy.daybased.lookback.partitions) day based partitions picks the small file slices within those partitions.
write.log_block.size	128	Max log block size in MB for log file, default 128MB
write.tasks	4	Parallelism of tasks that do actual write, default is 4
clean.async.enabled	true	Whether to cleanup the old commits immediately on new commits, enabled by default
clean.retain_commits	30	Number of commits to retain. So data will be retained for num_of_commits * time_between_commits (scheduled). This also directly translates into how much you can incrementally pull on this table, default 30
archive.max_commits	50	Max number of commits to keep before archiving older commits into a sequential log, default 50
write.index_bootstrap.tasks	N/A	Parallelism of tasks that do index bootstrap, default is the parallelism of the execution environment
write.task.max.size	1024.0	Maximum memory in MB for a write task, when the threshold hits, it flushes the max size data bucket to avoid OOM, default 1GB
hoodie.datasource.write.recordkey.field	uuid	Record key field. Value to be used as the  component of . Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg:
compaction.delta_seconds	3600	Max delta seconds time needed to trigger compaction, default 1 hour
hive_sync.partition_fields	(Optional)	Partition fields for hive sync, default ''
read.streaming.enabled	false	Whether to read as streaming source, default false
hoodie.datasource.write.keygenerator.type	SIMPLE	Key generator type, that implements will extract the key out of incoming record
clean.retain_file_versions	5	Number of file versions to retain. default 5
compaction.max_memory	100	Max memory in MB for compaction spillable map, default 100MB
hive_sync.support_timestamp	true	INT64 with original type TIMESTAMP_MICROS is converted to hive timestamp type. Disabled by default for backward compatibility.
hive_sync.skip_ro_suffix	false	Skip the _ro suffix for Read optimized table when registering, default false
metadata.compaction.delta_commits	10	Max delta commits for metadata table to trigger compaction, default 10
hive_sync.assume_date_partitioning	false	Assume partitioning is yyyy/mm/dd, default false
write.parquet.block.size	120	Parquet RowGroup size. It's recommended to make this large enough that scan costs can be amortized by packing enough column values into a single row group.
clustering.plan.strategy.target.file.max.bytes	1073741824	Each group can produce 'N' (CLUSTERING_MAX_GROUP_SIZE/CLUSTERING_TARGET_FILE_SIZE) output file groups, default 1 GB
clustering.tasks	4	Parallelism of tasks that do actual clustering, default is 4
hive_sync.enable	false	Asynchronously sync Hive meta to HMS, default false
changelog.enabled	false	Whether to keep all the intermediate changes, we try to keep all the changes of a record when enabled: 1). The sink accept the UPDATE_BEFORE message; 2). The source try to emit every changes of a record. The semantics is best effort because the compaction job would finally merge all changes of a record into one. default false to have UPSERT semantics
read.streaming.check-interval	60	Check interval for streaming read of SECOND, default 1 minute
hoodie.datasource.merge.type	payload_combine	For Snapshot query on merge on read table. Use this key to define how the payloads are merged, in 1) skip_merge: read the base file records plus the log file records; 2) payload_combine: read the base file records first, for each record in base file, checks whether the key is in the log file records(combines the two records with same key for base and log file records), then read the left log file records
read.tasks	4	Parallelism of tasks that do actual read, default is 4
read.end-commit	N/A	End commit instant for reading, the commit time format should be 'yyyyMMddHHmmss'
write.log.max.size	1024	Maximum size allowed in MB for a log file before it is rolled over to the next version, default 1GB
clustering.plan.strategy.daybased.lookback.partitions	2	Number of partitions to list to create ClusteringPlan, default is 2
hive_sync.file_format	PARQUET	File format for hive sync, default 'PARQUET'
clustering.plan.strategy.max.num.groups	30	Maximum number of groups to create as part of ClusteringPlan. Increasing groups will increase parallelism, default is 30
index.type	FLINK_STATE	Index type of Flink write job, default is using state backed index.
read.data.skipping.enabled	false	Enables data-skipping allowing queries to leverage indexes to reduce the search space byskipping over files
clean.policy	KEEP_LATEST_COMMITS	Clean policy to manage the Hudi table. Available option: KEEP_LATEST_COMMITS, KEEP_LATEST_FILE_VERSIONS, KEEP_LATEST_BY_HOURS.Default is KEEP_LATEST_COMMITS.
hive_sync.password	hive	Password for hive sync, default 'hive'
hive_sync.use_jdbc	true	Use JDBC when hive synchronization is enabled, default true
hive_sync.jdbc_url	jdbc:hive2://localhost:10000	Jdbc URL for hive sync, default 'jdbc:hive2://localhost:10000'
read.start-commit	N/A	Start commit instant for reading, the commit time format should be 'yyyyMMddHHmmss', by default reading from the latest instant for streaming read
archive.min_commits	40	Min number of commits to keep before archiving older commits into a sequential log, default 40
index.partition.regex	.*	Whether to load partitions in state if partition path matchingï¼ default
hoodie.table.name	N/A	Table name to register to Hive metastore
hoodie.datasource.write.partitionpath.urlencode	false	Whether to encode the partition path url, default false
source.avro-schema.path	N/A	Source avro schema file path, the parsed schema is used for deserialization
write.insert.cluster	false	Whether to merge small files for insert mode, if true, the write throughput will decrease because the read/write of existing small file, only valid for COW table, default false
source.avro-schema	N/A	Source avro schema string, the parsed schema is used for deserialization
hive_sync.conf.dir	N/A	The hive configuration directory, where the hive-site.xml lies in, the file should be put on the client machine
write.rate.limit	0	Write record rate limit per second to prevent traffic jitter and improve stability, default 0 (no limit)
clean.retain_hours	24	Number of hours for which commits need to be retained. This config provides a more flexible option ascompared to number of commits retained for cleaning service. Setting this property ensures all the files, but the latest in a file group, corresponding to commits with commit times older than the configured number of hours to be retained are cleaned.
read.utc-timezone	true	Use UTC timezone or local timezone to the conversion between epoch time and LocalDateTime. Hive 0.x/1.x/2.x use local timezone. But Hive 3.x use UTC timezone, by default true
hoodie.datasource.query.type	snapshot	Decides how data files need to be read, in 1) Snapshot mode (obtain latest view, based on row & columnar data); 2) incremental mode (new data since an instantTime); 3) Read Optimized mode (obtain latest view, based on columnar data) .Default: snapshot
write.precombine.field	ts	Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)
write.parquet.page.size	1	Parquet page size. Page is the unit of read within a parquet file. Within a block, pages are compressed separately.
hive_sync.metastore.uris	(Optional)	Metastore uris for hive sync, default ''
write.merge.max_memory	100	Max memory in MB for merge, default 100MB
hoodie.storage.layout.type	DEFAULT	Type of storage layout. Possible options are [DEFAULT | BUCKET]
hoodie.storage.layout.partitioner.class	N/A	Partitioner class, it is used to distribute data in a specific way.
hoodie.write.commit.callback.on	false	Turn commit callback on/off. off by default.
hoodie.write.commit.callback.http.url	N/A	Callback host to be sent along with callback messages
hoodie.write.commit.callback.http.timeout.seconds	3	Callback timeout in seconds. 3 by default
hoodie.write.commit.callback.class	org.apache.hudi.callback.impl.HoodieWriteCommitHttpCallback	Full path of callback class and must be a subclass of HoodieWriteCommitCallback class, org.apache.hudi.callback.impl.HoodieWriteCommitHttpCallback by default
hoodie.write.commit.callback.http.api.key	hudi_write_commit_http_callback	Http callback API key. hudi_write_commit_http_callback by default
hoodie.cleaner.fileversions.retained	3	When KEEP_LATEST_FILE_VERSIONS cleaning policy is used,  the minimum number of file slices to retain in each file group, during cleaning.
hoodie.clean.max.commits	1	Number of commits after the last clean operation, before scheduling of a new clean is attempted.
hoodie.clean.allow.multiple	true	Allows scheduling/executing multiple cleans by enabling this config. If users prefer to strictly ensure clean requests should be mutually exclusive, .i.e. a 2nd clean will not be scheduled if another clean is not yet completed to avoid repeat cleaning of same files, they might want to disable this config.
hoodie.clean.automatic	true	When enabled, the cleaner table service is invoked immediately after each commit, to delete older file slices. It's recommended to enable this, to ensure metadata and data storage growth is bounded.
hoodie.cleaner.parallelism	200	Parallelism for the cleaning operation. Increase this if cleaning becomes slow.
hoodie.cleaner.incremental.mode	true	When enabled, the plans for each cleaner service run is computed incrementally off the events  in the timeline, since the last cleaner run. This is much more efficient than obtaining listings for the full table for each planning (even with a metadata table).
hoodie.clean.async	false	Only applies when hoodie.clean.automatic is turned on. When turned on runs cleaner async with writing, which can speed up overall write performance.
hoodie.clean.trigger.strategy	NUM_COMMITS	Controls how cleaning is scheduled. Valid options: NUM_COMMITS
hoodie.cleaner.delete.bootstrap.base.file	false	When set to true, cleaner also deletes the bootstrap base file when it's skeleton base file is  cleaned. Turn this to true, if you want to ensure the bootstrap dataset storage is reclaimed over time, as the table receives updates/deletes. Another reason to turn this on, would be to ensure data residing in bootstrap  base files are also physically deleted, to comply with data privacy enforcement processes.
hoodie.cleaner.hours.retained	24	Number of hours for which commits need to be retained. This config provides a more flexible option ascompared to number of commits retained for cleaning service. Setting this property ensures all the files, but the latest in a file group, corresponding to commits with commit times older than the configured number of hours to be retained are cleaned.
hoodie.cleaner.commits.retained	10	Number of commits to retain, without cleaning. This will be retained for num_of_commits * time_between_commits (scheduled). This also directly translates into how much data retention the table supports for incremental queries.
hoodie.cleaner.policy.failed.writes	EAGER	Cleaning policy for failed writes to be used. Hudi will delete any files written by failed writes to re-claim space. Choose to perform this rollback of failed writes eagerly before every writer starts (only supported for single writer) or lazily by the cleaner (required for multi-writers)
hoodie.cleaner.policy	KEEP_LATEST_COMMITS	Cleaning policy to be used. The cleaner service deletes older file slices files to re-claim space. By default, cleaner spares the file slices written by the last N commits, determined by  hoodie.cleaner.commits.retained Long running query plans may often refer to older file slices and will break if those are cleaned, before the query has had   a chance to run. So, it is good to make sure that the data is retained for more than the maximum query execution time
hoodie.metastore.uris	thrift://localhost:9090	Metastore server uris
hoodie.metastore.enable	false	Use metastore server to store hoodie table metadata
hoodie.metastore.connect.retries	3	Number of retries while opening a connection to metastore
hoodie.metastore.connect.retry.delay	1	Number of seconds for the client to wait between consecutive connection attempts
hoodie.table.precombine.field	N/A	Field used in preCombining before actual write. By default, when two records have the same key value, the largest value for the precombine field determined by Object.compareTo(..), is picked.
hoodie.archivelog.folder	archived	path under the meta folder, to store archived timeline instants at.
hoodie.table.type	COPY_ON_WRITE	The table type for the underlying data, for this write. This canât change between writes.
hoodie.table.timeline.timezone	LOCAL	User can set hoodie commit timeline timezone, such as utc, local and so on. local is default
hoodie.partition.metafile.use.base.format	false	If true, partition metafiles are saved in the same format as base-files for this dataset (e.g. Parquet / ORC). If false (default) partition metafiles are saved as properties files.
hoodie.table.checksum	N/A	Table checksum is used to guard against partial writes in HDFS. It is added as the last entry in hoodie.properties and then used to validate while reading table config.
hoodie.table.create.schema	N/A	Schema used when creating the table, for the first time.
hoodie.table.recordkey.fields	N/A	Columns used to uniquely identify the table. Concatenated values of these fields are used as  the record key component of HoodieKey.
hoodie.table.log.file.format	HOODIE_LOG	Log format used for the delta logs.
hoodie.bootstrap.index.enable	true	Whether or not, this is a bootstrapped table, with bootstrap base data and an mapping index defined, default true.
hoodie.table.metadata.partitions	N/A	Comma-separated list of metadata partitions that have been completely built and in-sync with data table. These partitions are ready for use by the readers
hoodie.table.metadata.partitions.inflight	N/A	Comma-separated list of metadata partitions whose building is in progress. These partitions are not yet ready for use by the readers.
hoodie.table.partition.fields	N/A	Fields used to partition the table. Concatenated values of these fields are used as the partition path, by invoking toString()
hoodie.populate.meta.fields	true	When enabled, populates all meta fields. When disabled, no meta fields are populated and incremental queries will not be functional. This is only meant to be used for append only/immutable data for batch processing
hoodie.compaction.payload.class	org.apache.hudi.common.model.OverwriteWithLatestAvroPayload	Payload class to use for performing compactions, i.e merge delta logs with current base file and then  produce a new base file.
hoodie.bootstrap.index.class	org.apache.hudi.common.bootstrap.index.HFileBootstrapIndex	Implementation to use, for mapping base files to bootstrap base file, that contain actual data.
hoodie.datasource.write.partitionpath.urlencode	false	Should we url encode the partition path value, before creating the folder structure.
hoodie.datasource.write.hive_style_partitioning	false	Flag to indicate whether to use Hive style partitioning. If set true, the names of partition folders follow <partition_column_name>=<partition_value> format. By default false (the names of partition folders are only partition values)
hoodie.table.keygenerator.class	N/A	Key Generator class property for the hoodie table
hoodie.table.version	ZERO	Version of table, used for running upgrade/downgrade steps between releases with potentially breaking/backwards compatible changes.
hoodie.table.base.file.format	PARQUET	Base file format to store all the base file data.
hoodie.bootstrap.base.path	N/A	Base path of the dataset that needs to be bootstrapped as a Hudi table
hoodie.datasource.write.drop.partition.columns	false	When set to true, will not write the partition columns into hudi. By default, false.
hoodie.database.name	N/A	Database name that will be used for incremental query.If different databases have the same table name during incremental query, we can set it to limit the table name under a specific database
hoodie.timeline.layout.version	N/A	Version of timeline used, by the table.
hoodie.table.name	N/A	Table name that will be used for registering with Hive. Needs to be same across runs.
hoodie.memory.merge.fraction	0.6	This fraction is multiplied with the user memory fraction (1 - spark.memory.fraction) to get a final fraction of heap space to use during merge
hoodie.memory.dfs.buffer.max.size	16777216	Property to control the max memory in bytes for dfs input stream buffer size
hoodie.memory.writestatus.failure.fraction	0.1	Property to control how what fraction of the failed record, exceptions we report back to driver. Default is 10%. If set to 100%, with lot of failures, this can cause memory pressure, cause OOMs and mask actual data errors.
hoodie.memory.compaction.fraction	0.6	HoodieCompactedLogScanner reads logblocks, converts records to HoodieRecords and then merges these log blocks and records. At any point, the number of entries in a log block can be less than or equal to the number of entries in the corresponding parquet file. This can lead to OOM in the Scanner. Hence, a spillable map helps alleviate the memory pressure. Use this config to set the max allowable inMemory footprint of the spillable map
hoodie.memory.merge.max.size	1073741824	Maximum amount of memory used  in bytes for merge operations, before spilling to local storage.
hoodie.memory.spillable.map.path	/tmp/	Default file path prefix for spillable map
hoodie.memory.compaction.max.size	N/A	Maximum amount of memory used  in bytes for compaction operations in bytes , before spilling to local storage.
hoodie.write.lock.dynamodb.billing_mode	PAY_PER_REQUEST	For DynamoDB based lock provider, by default it is PAY_PER_REQUEST mode
hoodie.write.lock.dynamodb.table	N/A	For DynamoDB based lock provider, the name of the DynamoDB table acting as lock table
hoodie.write.lock.dynamodb.region	us-east-1	For DynamoDB based lock provider, the region used in endpoint for Amazon DynamoDB service. Would try to first get it from AWS_REGION environment variable. If not find, by default use us-east-1
hoodie.write.lock.dynamodb.partition_key	N/A	For DynamoDB based lock provider, the partition key for the DynamoDB lock table. Each Hudi dataset should has it's unique key so concurrent writers could refer to the same partition key. By default we use the Hudi table name specified to be the partition key
hoodie.write.lock.dynamodb.write_capacity	10	For DynamoDB based lock provider, write capacity units when using PROVISIONED billing mode
hoodie.write.lock.dynamodb.table_creation_timeout	600000	For DynamoDB based lock provider, the maximum number of milliseconds to wait for creating DynamoDB table
hoodie.write.lock.dynamodb.read_capacity	20	For DynamoDB based lock provider, read capacity units when using PROVISIONED billing mode
hoodie.write.lock.dynamodb.endpoint_url	N/A	For DynamoDB based lock provider, the url endpoint used for Amazon DynamoDB service. Useful for development with a local dynamodb instance.
hoodie.logfile.data.block.max.size	268435456	LogFile Data block max size in bytes. This is the maximum size allowed for a single data block to be appended to a log file. This helps to make sure the data appended to the log file is broken up into sizable blocks to prevent from OOM errors. This size should be greater than the JVM memory.
hoodie.parquet.outputtimestamptype	TIMESTAMP_MICROS	Sets spark.sql.parquet.outputTimestampType. Parquet timestamp type to use when Spark writes data to Parquet files.
hoodie.orc.stripe.size	67108864	Size of the memory buffer in bytes for writing
hoodie.orc.block.size	125829120	ORC block size, recommended to be aligned with the target file size.
hoodie.orc.compression.codec	ZLIB	Compression codec to use for ORC base files.
hoodie.parquet.max.file.size	125829120	Target size in bytes for parquet files produced by Hudi write phases. For DFS, this needs to be aligned with the underlying filesystem block size for optimal performance.
hoodie.hfile.max.file.size	125829120	Target file size in bytes for HFile base files.
hoodie.parquet.writelegacyformat.enabled	false	Sets spark.sql.parquet.writeLegacyFormat. If true, data will be written in a way of Spark 1.4 and earlier. For example, decimal values will be written in Parquet's fixed-length byte array format which other systems such as Apache Hive and Apache Impala use. If false, the newer format in Parquet will be used. For example, decimals will be written in int-based format.
hoodie.parquet.block.size	125829120	Parquet RowGroup size in bytes. It's recommended to make this large enough that scan costs can be amortized by packing enough column values into a single row group.
hoodie.logfile.max.size	1073741824	LogFile max size in bytes. This is the maximum size allowed for a log file before it is rolled over to the next version.
hoodie.parquet.dictionary.enabled	true	Whether to use dictionary encoding
hoodie.hfile.block.size	1048576	Lower values increase the size in bytes of metadata tracked within HFile, but can offer potentially faster lookup times.
hoodie.parquet.field_id.write.enabled	true	Would only be effective with Spark 3.3+. Sets spark.sql.parquet.fieldId.write.enabled. If enabled, Spark will write out parquet native field ids that are stored inside StructField's metadata as parquet.field.id to parquet files.
hoodie.parquet.page.size	1048576	Parquet page size in bytes. Page is the unit of read within a parquet file. Within a block, pages are compressed separately.
hoodie.hfile.compression.algorithm	GZ	Compression codec to use for hfile base files.
hoodie.orc.max.file.size	125829120	Target file size in bytes for ORC base files.
hoodie.logfile.data.block.format	N/A	Format of the data block within delta logs. Following formats are currently supported "avro", "hfile", "parquet"
hoodie.logfile.to.parquet.compression.ratio	0.35	Expected additional compression as records move from log files to parquet. Used for merge_on_read table to send inserts into log files & control the size of compacted parquet file.
hoodie.parquet.compression.ratio	0.1	Expected compression of parquet data used by Hudi, when it tries to size new parquet files. Increase this value, if bulk_insert is producing smaller than expected sized files
hoodie.parquet.compression.codec	gzip	Compression Codec for parquet files
hoodie.archive.merge.small.file.limit.bytes	20971520	This config sets the archive file size limit below which an archive file becomes a candidate to be selected as such a small file.
hoodie.keep.max.commits	30	Archiving service moves older entries from timeline into an archived log after each write, to  keep the metadata overhead constant, even as the table size grows.This config controls the maximum number of instants to retain in the active timeline.
hoodie.archive.merge.enable	false	When enable, hoodie will auto merge several small archive files into larger one. It's useful when storage scheme doesn't support append operation.
hoodie.archive.automatic	true	When enabled, the archival table service is invoked immediately after each commit, to archive commits if we cross a maximum value of commits. It's recommended to enable this, to ensure number of active commits is bounded.
hoodie.archive.delete.parallelism	100	Parallelism for deleting archived hoodie commits.
hoodie.archive.beyond.savepoint	false	If enabled, archival will proceed beyond savepoint, skipping savepoint commits. If disabled, archival will stop at the earliest savepoint commit.
hoodie.commits.archival.batch	10	Archiving of instants is batched in best-effort manner, to pack more instants into a single archive log. This config controls such archival batch size.
hoodie.archive.async	false	Only applies when hoodie.archive.automatic is turned on. When turned on runs archiver async with writing, which can speed up overall write performance.
hoodie.keep.min.commits	20	Similar to hoodie.keep.max.commits, but controls the minimum number ofinstants to retain in the active timeline.
hoodie.archive.merge.files.batch.size	10	The number of small archive files to be merged at once.
hoodie.metadata.index.column.stats.parallelism	10	Parallelism to use, when generating column stats index.
hoodie.metadata.compact.max.delta.commits	10	Controls how often the metadata table is compacted.
hoodie.assume.date.partitioning	false	Should HoodieWriteClient assume the data is partitioned by dates, i.e three levels from base path. This is a stop-gap to support tables created by versions < 0.3.1. Will be removed eventually
hoodie.metadata.metrics.enable	false	Enable publishing of metrics around metadata table.
hoodie.metadata.index.bloom.filter.file.group.count	4	Metadata bloom filter index partition file group count. This controls the size of the base and log files and read parallelism in the bloom filter index partition. The recommendation is to size the file group count such that the base files are under 1GB.
_hoodie.metadata.ignore.spurious.deletes	true	There are cases when extra files are requested to be deleted from metadata table which are never added before. This config determines how to handle such spurious deletes
hoodie.file.listing.parallelism	200	Parallelism to use, when listing the table on lake storage.
hoodie.metadata.index.async	false	Enable asynchronous indexing of metadata table.
hoodie.metadata.index.column.stats.column.list	N/A	Comma-separated list of columns for which column stats index will be built. If not set, all columns will be indexed
hoodie.metadata.enable.full.scan.log.files	true	Enable full scanning of log files while reading log records. If disabled, Hudi does look up of only interested entries.
hoodie.metadata.index.bloom.filter.enable	false	Enable indexing bloom filters of user data files under metadata table. When enabled, metadata table will have a partition to store the bloom filter index and will be used during the index lookups.
hoodie.metadata.clean.async	false	Enable asynchronous cleaning for metadata table
hoodie.metadata.keep.max.commits	30	Similar to hoodie.metadata.keep.min.commits, this config controls the maximum number of instants to retain in the active timeline.
hoodie.metadata.insert.parallelism	1	Parallelism to use when inserting to the metadata table
hoodie.metadata.dir.filter.regex	(Optional)	Directories matching this regex, will be filtered out when initializing metadata table from lake storage for the first time.
hoodie.metadata.index.column.stats.processing.mode.override	N/A	By default Column Stats Index is automatically determining whether it should be read and processed either'in-memory' (w/in executing process) or using Spark (on a cluster), based on some factors like the size of the Index and how many columns are read. This config allows to override this behavior.
hoodie.metadata.keep.min.commits	20	Archiving service moves older entries from metadata tableâs timeline into an archived log after each write, to keep the overhead constant, even as the metadata table size grows.  This config controls the minimum number of instants to retain in the active timeline.
hoodie.metadata.index.column.stats.inMemory.projection.threshold	100000	When reading Column Stats Index, if the size of the expected resulting projection is below the in-memory threshold (counted by the # of rows), it will be attempted to be loaded "in-memory" (ie not using the execution engine like Spark, Flink, etc). If the value is above the threshold execution engine will be used to compose the projection.
hoodie.metadata.index.column.stats.enable	false	Enable indexing column ranges of user data files under metadata table key lookups. When enabled, metadata table will have a partition to store the column ranges and will be used for pruning files during the index lookups.
hoodie.metadata.index.bloom.filter.column.list	N/A	Comma-separated list of columns for which bloom filter index will be built. If not set, only record key will be indexed.
hoodie.metadata.cleaner.commits.retained	3	Number of commits to retain, without cleaning, on metadata table.
hoodie.metadata.index.check.timeout.seconds	900	After the async indexer has finished indexing upto the base instant, it will ensure that all inflight writers reliably write index updates as well. If this timeout expires, then the indexer will abort itself safely.
hoodie.metadata.populate.meta.fields	false	When enabled, populates all meta fields. When disabled, no meta fields are populated.
hoodie.metadata.index.column.stats.file.group.count	2	Metadata column stats partition file group count. This controls the size of the base and log files and read parallelism in the column stats index partition. The recommendation is to size the file group count such that the base files are under 1GB.
hoodie.metadata.enable	true	Enable the internal metadata table which serves table metadata like level file listings
hoodie.metadata.index.bloom.filter.parallelism	200	Parallelism to use for generating bloom filter index in metadata table.
hoodie.optimistic.consistency.guard.sleep_time_ms	500	Amount of time (in ms), to wait after which we assume storage is consistent.
hoodie.consistency.check.max_interval_ms	20000	Maximum amount of time (in ms), to wait for consistency checking.
_hoodie.optimistic.consistency.guard.enable	false	Enable consistency guard, which optimistically assumes consistency is achieved after a certain time period.
hoodie.consistency.check.enabled	false	Enabled to handle S3 eventual consistency issue. This property is no longer required since S3 is now strongly consistent. Will be removed in the future releases.
hoodie.consistency.check.max_checks	6	Maximum number of consistency checks to perform, with exponential backoff.
hoodie.consistency.check.initial_interval_ms	400	Amount of time (in ms) to wait, before checking for consistency after an operation on storage.
hoodie.filesystem.operation.retry.max_interval_ms	2000	Maximum amount of time (in ms), to wait for next retry.
hoodie.filesystem.operation.retry.enable	false	Enabled to handle list/get/delete etc file system performance issue.
hoodie.filesystem.operation.retry.max_numbers	4	Maximum number of retry actions to perform, with exponential backoff.
hoodie.filesystem.operation.retry.exceptions	(Optional)	The class name of the Exception that needs to be re-tryed, separated by commas. Default is empty which means retry all the IOException and RuntimeException from FileSystem
hoodie.filesystem.operation.retry.initial_interval_ms	100	Amount of time (in ms) to wait, before retry to do operations on storage.
hoodie.combine.before.upsert	true	When upserted records share same key, controls whether they should be first combined (i.e de-duplicated) before writing to storage. This should be turned off only if you are absolutely certain that there are no duplicates incoming,  otherwise it can lead to duplicate keys and violate the uniqueness guarantees.
hoodie.write.markers.type	TIMELINE_SERVER_BASED	Marker type to use.  Two modes are supported: - DIRECT: individual marker file corresponding to each data file is directly created by the writer. - TIMELINE_SERVER_BASED: marker operations are all handled at the timeline service which serves as a proxy.  New marker entries are batch processed and stored in a limited number of underlying files for efficiency.  If HDFS is used or timeline server is disabled, DIRECT markers are used as fallback even if this is configure.  For Spark structured streaming, this configuration does not take effect, i.e., DIRECT markers are always used for Spark structured streaming.
hoodie.consistency.check.max_interval_ms	300000	Max time to wait between successive attempts at performing consistency checks
hoodie.embed.timeline.server.port	0	Port at which the timeline server listens for requests. When running embedded in each writer, it picks a free port and communicates to all the executors. This should rarely be changed.
hoodie.auto.adjust.lock.configs	false	Auto adjust lock configurations when metadata table is enabled and for async table services.
hoodie.table.services.enabled	true	Master control to disable all table services including archive, clean, compact, cluster, etc.
hoodie.table.base.file.format	PARQUET	Base file format to store all the base file data.
hoodie.avro.schema.validate	false	Validate the schema used for the write against the latest schema, for backwards compatibility.
hoodie.write.buffer.limit.bytes	4194304	Size of in-memory buffer used for parallelizing network reads and lake storage writes.
hoodie.insert.shuffle.parallelism	200	Parallelism for inserting records into the table. Inserts can shuffle data before writing to tune file sizes and optimize the storage layout.
hoodie.embed.timeline.server.async	false	Controls whether or not, the requests to the timeline server are processed in asynchronous fashion, potentially improving throughput.
hoodie.rollback.parallelism	100	Parallelism for rollback of commits. Rollbacks perform delete of files or logging delete blocks to file groups on storage in parallel.
hoodie.write.status.storage.level	MEMORY_AND_DISK_SER	Write status objects hold metadata about a write (stats, errors), that is not yet committed to storage. This controls the how that information is cached for inspection by clients. We rarely expect this to be changed.
hoodie.writestatus.class	org.apache.hudi.client.WriteStatus	Subclass of org.apache.hudi.client.WriteStatus to be used to collect information about a write. Can be overridden to collection additional metrics/statistics about the data if needed.
hoodie.base.path	N/A	Base path on lake storage, under which all the table data is stored. Always prefix it explicitly with the storage scheme (e.g hdfs://, s3:// etc). Hudi stores all the main meta-data about commits, savepoints, cleaning audit logs etc in .hoodie directory under this base path directory.
hoodie.allow.empty.commit	true	Whether to allow generation of empty commits, even if no data was written in the commit. It's useful in cases where extra metadata needs to be published regardless e.g tracking source offsets when ingesting data
hoodie.bulkinsert.user.defined.partitioner.class	N/A	If specified, this class will be used to re-partition records before they are bulk inserted. This can be used to sort, pack, cluster data optimally for common query patterns. For now we support a build-in user defined bulkinsert partitioner org.apache.hudi.execution.bulkinsert.RDDCustomColumnsSortPartitioner which can does sorting based on specified column values set by hoodie.bulkinsert.user.defined.partitioner.sort.columns
hoodie.table.name	N/A	Table name that will be used for registering with metastores like HMS. Needs to be same across runs.
hoodie.combine.before.delete	true	During delete operations, controls whether we should combine deletes (and potentially also upserts) before  writing to storage.
hoodie.embed.timeline.server.threads	-1	Number of threads to serve requests in the timeline server. By default, auto configured based on the number of underlying cores.
hoodie.fileid.prefix.provider.class	org.apache.hudi.table.RandomFileIdPrefixProvider	File Id Prefix provider class, that implements
hoodie.fail.on.timeline.archiving	true	Timeline archiving removes older instants from the timeline, after each write operation, to minimize metadata overhead. Controls whether or not, the write should be failed as well, if such archiving fails.
hoodie.datasource.write.keygenerator.class	N/A	Key generator class, that implements  extract a key out of incoming records.
hoodie.combine.before.insert	false	When inserted records share same key, controls whether they should be first combined (i.e de-duplicated) before writing to storage.
hoodie.embed.timeline.server.gzip	true	Controls whether gzip compression is used, for large responses from the timeline server, to improve latency.
hoodie.markers.timeline_server_based.batch.interval_ms	50	The batch interval in milliseconds for marker creation batch processing
hoodie.skip.default.partition.validation	false	When table is upgraded from pre 0.12 to 0.12, we check for "default" partition and fail if found one. Users are expected to rewrite the data in those partitions. Enabling this config will bypass this validation
hoodie.markers.timeline_server_based.batch.num_threads	20	Number of threads to use for batch processing marker creation requests at the timeline server
_.hoodie.allow.multi.write.on.same.instant  false
hoodie.datasource.write.payload.class	org.apache.hudi.common.model.OverwriteWithLatestAvroPayload	Payload class used. Override this, if you like to roll your own merge logic, when upserting/inserting. This will render any value set for PRECOMBINE_FIELD_OPT_VAL in-effective
hoodie.bulkinsert.shuffle.parallelism	200	For large initial imports using bulk_insert operation, controls the parallelism to use for sort modes or custom partitioning donebefore writing records to the table.
hoodie.delete.shuffle.parallelism	200	Parallelism used for âdeleteâ operation. Delete operations also performs shuffles, similar to upsert operation.
hoodie.consistency.check.max_checks	7	Maximum number of checks, for consistency of written data.
hoodie.datasource.write.keygenerator.type	SIMPLE	Easily configure one the built-in key generators, instead of specifying the key generator class.Currently supports SIMPLE, COMPLEX, TIMESTAMP, CUSTOM, NON_PARTITION, GLOBAL_DELETE
hoodie.merge.allow.duplicate.on.inserts	false	When enabled, we allow duplicate keys even if inserts are routed to merge with an existing file (for ensuring file sizing). This is only relevant for insert operation, since upsert, delete operations will ensure unique key constraints are maintained.
hoodie.embed.timeline.server.reuse.enabled	false	Controls whether the timeline server instance should be cached and reused across the JVM (across task lifecycles)to avoid startup costs. This should rarely be changed.
hoodie.datasource.write.precombine.field	ts	Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)
hoodie.bulkinsert.sort.mode	NONE	Sorting modes to use for sorting records for bulk insert. This is use when user hoodie.bulkinsert.user.defined.partitioner.classis not configured. Available values are - GLOBAL_SORT: this ensures best file sizes, with lowest memory overhead at cost of sorting. PARTITION_SORT: Strikes a balance by only sorting within a partition, still keeping the memory overhead of writing lowest and best effort file sizing. NONE: No sorting. Fastest and matches  in terms of number of files, overheads
hoodie.avro.schema	N/A	Schema string representing the current write schema of the table. Hudi passes this to implementations of HoodieRecordPayload to convert incoming records to avro. This is also used as the write schema evolving records during an update.
hoodie.auto.commit	true	Controls whether a write operation should auto commit. This can be turned off to perform inspection of the uncommitted write before deciding to commit.
hoodie.embed.timeline.server	true	When true, spins up an instance of the timeline server (meta server that serves cached file listings, statistics),running on each writer's driver process, accepting requests during the write from executors.
hoodie.timeline.layout.version	1	Controls the layout of the timeline. Version 0 relied on renames, Version 1 (default) models the timeline as an immutable log relying only on atomic writes for object storage.
hoodie.schema.cache.enable	false	cache query internalSchemas in driver/executor side
hoodie.upsert.shuffle.parallelism	200	Parallelism to use for upsert operation on the table. Upserts can shuffle data to perform index lookups, file sizing, bin packing records optimallyinto file groups.
hoodie.write.schema	N/A	The specified write schema. In most case, we do not need set this parameter, but for the case the write schema is not equal to the specified table schema, we can specify the write schema by this parameter. Used by MergeIntoHoodieTableCommand
hoodie.rollback.using.markers	true	Enables a more efficient mechanism for rollbacks based on the marker files generated during the writes. Turned on by default.
hoodie.merge.data.validation.enabled	false	When enabled, data validation checks are performed during merges to ensure expected number of records after merge operation.
hoodie.internal.schema	N/A	Schema string representing the latest schema of the table. Hudi passes this to implementations of evolution of schema
hoodie.client.heartbeat.tolerable.misses	2	Number of heartbeat misses, before a writer is deemed not alive and all pending writes are aborted.
hoodie.write.concurrency.mode	SINGLE_WRITER	Enable different concurrency modes. Options are SINGLE_WRITER: Only one active writer to the table. Maximizes throughputOPTIMISTIC_CONCURRENCY_CONTROL: Multiple writers can operate on the table and exactly one of them succeed if a conflict (writes affect the same file group) is detected.
hoodie.markers.delete.parallelism	100	Determines the parallelism for deleting marker files, which are used to track all files (valid or invalid/partial) written during a write operation. Increase this value if delays are observed, with large batch writes.
hoodie.release.resource.on.completion.enable	true	Control to enable release all persist rdds when the spark job finish.
hoodie.bulkinsert.user.defined.partitioner.sort.columns	N/A	Columns to sort the data by when use org.apache.hudi.execution.bulkinsert.RDDCustomColumnsSortPartitioner as user defined partitioner during bulk_insert. For example 'column1,column2'
hoodie.finalize.write.parallelism	200	Parallelism for the write finalization internal operation, which involves removing any partially written files from lake storage, before committing the write. Reduce this value, if the high number of tasks incur delays for smaller tables or low latency writes.
hoodie.merge.small.file.group.candidates.limit	1	Limits number of file groups, whose base file satisfies small-file limit, to consider for appending records during upsert operation. Only applicable to MOR tables
hoodie.client.heartbeat.interval_in_ms	60000	Writers perform heartbeats to indicate liveness. Controls how often (in ms), such heartbeats are registered to lake storage.
hoodie.allow.operation.metadata.field	false	Whether to include '_hoodie_operation' in the metadata fields. Once enabled, all the changes of a record are persisted to the delta log directly without merge
hoodie.consistency.check.initial_interval_ms	2000	Initial time between successive attempts to ensure written data's metadata is consistent on storage. Grows with exponential backoff after the initial value.
hoodie.avro.schema.external.transformation	false	When enabled, records in older schema are rewritten into newer schema during upsert,delete and background compaction,clustering operations.
hoodie.datasource.write.partitionpath.urlencode	false	Should we url encode the partition path value, before creating the folder structure.
hoodie.datasource.write.hive_style_partitioning	false	Flag to indicate whether to use Hive style partitioning. If set true, the names of partition folders follow <partition_column_name>=<partition_value> format. By default false (the names of partition folders are only partition values)
hoodie.datasource.write.keygenerator.consistent.logical.timestamp.enabled	false	When set to true, consistent value will be generated for a logical timestamp type column, like timestamp-millis and timestamp-micros, irrespective of whether row-writer is enabled. Disabled by default so as not to break the pipeline that deploy either fully row-writer path or non row-writer path. For example, if it is kept disabled then record key of timestamp type with value  will be written as timestamp  in row-writer path, while it will be written as long value  in non row-writer path. If enabled, then the timestamp value will be written in both the cases.
hoodie.datasource.write.partitionpath.field	N/A	Partition path field. Value to be used at the partitionPath component of HoodieKey. Actual value ontained by invoking .toString()
hoodie.datasource.write.recordkey.field	uuid	Record key field. Value to be used as the  component of . Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg:
hoodie.index.hbase.zkport	N/A	Only applies if index type is HBASE. HBase ZK Quorum port to connect to
hoodie.index.hbase.put.batch.size.autocompute	false	Property to set to enable auto computation of put batch size
hoodie.index.hbase.bucket.number	8	Only applicable when using RebalancedSparkHoodieHBaseIndex, same as hbase regions count can get the best performance
hoodie.index.hbase.rollback.sync	false	When set to true, the rollback method will delete the last failed task index. The default value is false. Because deleting the index will add extra load on the Hbase cluster for each rollback
hoodie.index.hbase.max.qps.per.region.server	1000	Property to set maximum QPS allowed per Region Server. This should be same across various jobs. This is intended to limit the aggregate QPS generated across various jobs to an Hbase Region Server. It is recommended to set this value based on global indexing throughput needs and most importantly, how much the HBase installation in use is able to tolerate without Region Servers going down.
hoodie.index.hbase.min.qps.fraction	N/A	Minimum for HBASE_QPS_FRACTION_PROP to stabilize skewed write workloads
hoodie.index.hbase.zk.connection_timeout_ms	15000	Timeout to use for establishing connection with zookeeper, from HBase client.
hoodie.index.hbase.table	N/A	Only applies if index type is HBASE. HBase Table name to use as the index. Hudi stores the row_key and [partition_path, fileID, commitTime] mapping in the table
hoodie.index.hbase.zknode.path	N/A	Only applies if index type is HBASE. This is the root znode that will contain all the znodes created/used by HBase
hoodie.index.hbase.kerberos.user.keytab	N/A	File name of the kerberos keytab file for connecting to the hbase cluster.
hoodie.index.hbase.zkquorum	N/A	Only applies if index type is HBASE. HBase ZK Quorum url to connect to
hoodie.index.hbase.qps.fraction	0.5	Property to set the fraction of the global share of QPS that should be allocated to this job. Let's say there are 3 jobs which have input size in terms of number of rows required for HbaseIndexing as x, 2x, 3x respectively. Then this fraction for the jobs would be (0.17) 1/6, 0.33 (2/6) and 0.5 (3/6) respectively. Default is 50%, which means a total of 2 jobs can run using HbaseIndex without overwhelming Region Servers.
hoodie.index.hbase.zk.session_timeout_ms	60000	Session timeout value to use for Zookeeper failure detection, for the HBase client.Lower this value, if you want to fail faster.
hoodie.index.hbase.put.batch.size	100	Controls the batch size for performing puts against HBase. Batching improves throughput, by saving round trips.
hoodie.hbase.index.update.partition.path	false	Only applies if index type is HBASE. When an already existing record is upserted to a new partition compared to whats in storage, this config when set, will delete old record in old partition and will insert it as new record in new partition.
hoodie.index.hbase.security.authentication	simple	Property to decide if the hbase cluster secure authentication is enabled or not. Possible values are 'simple' (no authentication), and 'kerberos'.
hoodie.index.hbase.qps.allocator.class	org.apache.hudi.index.hbase.DefaultHBaseQPSResourceAllocator	Property to set which implementation of HBase QPS resource allocator to be used, whichcontrols the batching rate dynamically.
hoodie.index.hbase.get.batch.size	100	Controls the batch size for performing gets against HBase. Batching improves throughput, by saving round trips.
hoodie.index.hbase.zkpath.qps_root	/QPS_ROOT	chroot in zookeeper, to use for all qps allocation co-ordination.
hoodie.index.hbase.max.qps.fraction	N/A	Maximum for HBASE_QPS_FRACTION_PROP to stabilize skewed write workloads
hoodie.index.hbase.regionserver.kerberos.principal	N/A	The value of hbase.regionserver.kerberos.principal in hbase cluster.
hoodie.index.hbase.dynamic_qps	false	Property to decide if HBASE_QPS_FRACTION_PROP is dynamically calculated based on write volume.
hoodie.index.hbase.master.kerberos.principal	N/A	The value of hbase.master.kerberos.principal in hbase cluster.
hoodie.index.hbase.kerberos.user.principal	N/A	The kerberos principal name for connecting to the hbase cluster.
hoodie.index.hbase.desired_puts_time_in_secs    600
hoodie.index.hbase.sleep.ms.for.put.batch   N/A
hoodie.index.hbase.sleep.ms.for.get.batch   N/A
hoodie.write.commit.callback.pulsar.operation-timeout	30s	Duration of waiting for completing an operation.
hoodie.write.commit.callback.pulsar.topic	N/A	pulsar topic name to publish timeline activity into.
hoodie.write.commit.callback.pulsar.producer.block-if-queue-full	true	When the queue is full, the method is blocked instead of an exception is thrown.
hoodie.write.commit.callback.pulsar.producer.send-timeout	30s	The timeout in each sending to pulsar.
hoodie.write.commit.callback.pulsar.broker.service.url	N/A	Server's url of pulsar cluster, to be used for publishing commit metadata.
hoodie.write.commit.callback.pulsar.keepalive-interval	30s	Duration of keeping alive interval for each client broker connection.
hoodie.write.commit.callback.pulsar.producer.pending-total-size	50000	The maximum number of pending messages across partitions.
hoodie.write.commit.callback.pulsar.request-timeout	60s	Duration of waiting for completing a request.
hoodie.write.commit.callback.pulsar.producer.pending-queue-size	1000	The maximum size of a queue holding pending messages.
hoodie.write.commit.callback.pulsar.producer.route-mode	RoundRobinPartition	Message routing logic for producers on partitioned topics.
hoodie.write.commit.callback.pulsar.connection-timeout	10s	Duration of waiting for a connection to a broker to be established.
hoodie.write.commit.callback.kafka.topic	N/A	Kafka topic name to publish timeline activity into.
hoodie.write.commit.callback.kafka.partition	N/A	It may be desirable to serialize all changes into a single Kafka partition  for providing strict ordering. By default, Kafka messages are keyed by table name, which  guarantees ordering at the table level, but not globally (or when new partitions are added)
hoodie.write.commit.callback.kafka.retries	3	Times to retry the produce. 3 by default
hoodie.write.commit.callback.kafka.acks	all	kafka acks level, all by default to ensure strong durability.
hoodie.write.commit.callback.kafka.bootstrap.servers	N/A	Bootstrap servers of kafka cluster, to be used for publishing commit metadata.
hoodie.write.lock.zookeeper.base_path	N/A	The base path on Zookeeper under which to create lock related ZNodes. This should be same for all concurrent writers to the same table
hoodie.write.lock.zookeeper.lock_key	N/A	Key name under base_path at which to create a ZNode and acquire lock. Final path on zk will look like base_path/lock_key. If this parameter is not set, we would set it as the table name
hoodie.write.lock.client.num_retries	10	Maximum number of times to retry to acquire lock additionally from the lock manager.
hoodie.write.lock.wait_time_ms_between_retry	1000	Initial amount of time to wait between retries to acquire locks,  subsequent retries will exponentially backoff.
hoodie.write.lock.num_retries	15	Maximum number of times to retry lock acquire, at each lock provider
hoodie.write.lock.wait_time_ms	60000	Timeout in ms, to wait on an individual lock acquire() call, at the lock provider.
hoodie.write.lock.zookeeper.connection_timeout_ms	15000	Timeout in ms, to wait for establishing connection with Zookeeper.
hoodie.write.lock.zookeeper.port	N/A	Zookeeper port to connect to.
hoodie.write.lock.hivemetastore.table	N/A	For Hive based lock provider, the Hive table to acquire lock against
hoodie.write.lock.zookeeper.url	N/A	Zookeeper URL to connect to.
hoodie.write.lock.filesystem.expire	0	For DFS based lock providers, expire time in minutes, must be a nonnegative number, default means no expire
hoodie.write.lock.filesystem.path	N/A	For DFS based lock providers, path to store the locks under. use Table's meta path as default
hoodie.write.lock.provider	org.apache.hudi.client.transaction.lock.ZookeeperBasedLockProvider	Lock provider class name, user can provide their own implementation of LockProvider which should be subclass of org.apache.hudi.common.lock.LockProvider
hoodie.write.lock.zookeeper.session_timeout_ms	60000	Timeout in ms, to wait after losing connection to ZooKeeper, before the session is expired
hoodie.write.lock.conflict.resolution.strategy	org.apache.hudi.client.transaction.SimpleConcurrentFileWritesConflictResolutionStrategy	Lock provider class name, this should be subclass of org.apache.hudi.client.transaction.ConflictResolutionStrategy
hoodie.write.lock.hivemetastore.database	N/A	For Hive based lock provider, the Hive database to acquire lock against
hoodie.write.lock.hivemetastore.uris	N/A	For Hive based lock provider, the Hive metastore URI to acquire locks against.
hoodie.write.lock.max_wait_time_ms_between_retry	5000	Maximum amount of time to wait between retries by lock provider client. This bounds the maximum delay from the exponential backoff. Currently used by ZK based lock provider only.
hoodie.write.lock.client.wait_time_ms_between_retry	10000	Amount of time to wait between retries on the lock provider by the lock manager
hoodie.compaction.lazy.block.read	true	When merging the delta log files, this config helps to choose whether the log blocks should be read lazily or not. Choose true to use lazy block reading (low memory usage, but incurs seeks to each block header) or false for immediate block read (higher memory usage)
hoodie.parquet.small.file.limit	104857600	During upsert operation, we opportunistically expand existing small files on storage, instead of writing new files, to keep number of files to an optimum. This config sets the file size limit below which a file on storage  becomes a candidate to be selected as such a . By default, treat any file <= 100MB as a small file. Also note that if this set <= 0, will not try to get small files and directly write new files
hoodie.compaction.strategy	org.apache.hudi.table.action.compact.strategy.LogFileSizeBasedCompactionStrategy	Compaction strategy decides which file groups are picked up for compaction during each compaction run. By default. Hudi picks the log file with most accumulated unmerged data
hoodie.copyonwrite.record.size.estimate	1024	The average record size. If not explicitly specified, hudi will compute the record size estimate compute dynamically based on commit metadata.  This is critical in computing the insert parallelism and bin-packing inserts into small files.
hoodie.compact.inline.max.delta.seconds	3600	Number of elapsed seconds after the last compaction, before scheduling a new one.
hoodie.compaction.target.io	512000	Amount of MBs to spend during compaction run for the LogFileSizeBasedCompactionStrategy. This value helps bound ingestion latency while compaction is run inline mode.
hoodie.compaction.logfile.size.threshold	0	Only if the log file size is greater than the threshold in bytes, the file group will be compacted.
hoodie.compaction.preserve.commit.metadata	true	When rewriting data, preserves existing hoodie_commit_time
hoodie.copyonwrite.insert.auto.split	true	Config to control whether we control insert split sizes automatically based on average record sizes. It's recommended to keep this turned on, since hand tuning is otherwise extremely cumbersome.
hoodie.compact.inline.max.delta.commits	5	Number of delta commits after the last compaction, before scheduling of a new compaction is attempted.
hoodie.record.size.estimation.threshold	1.0	We use the previous commits' metadata to calculate the estimated record size and use it  to bin pack records into partitions. If the previous commit is too small to make an accurate estimation,  Hudi will search commits in the reverse order, until we find a commit that has totalBytesWritten  larger than (PARQUET_SMALL_FILE_LIMIT_BYTES * this_threshold)
hoodie.compact.inline.trigger.strategy	NUM_COMMITS	Controls how compaction scheduling is triggered, by time or num delta commits or combination of both. Valid options: NUM_COMMITS,NUM_COMMITS_AFTER_LAST_REQUEST,TIME_ELAPSED,NUM_AND_TIME,NUM_OR_TIME
hoodie.compaction.reverse.log.read	false	HoodieLogFormatReader reads a logfile in the forward direction starting from pos=0 to pos=file_length. If this config is set to true, the reader reads the logfile in reverse direction, from pos=file_length to pos=0
hoodie.copyonwrite.insert.split.size	500000	Number of inserts assigned for each partition/bucket for writing. We based the default on writing out 100MB files, with at least 1kb records (100K records per file), and   over provision to 500K. As long as auto-tuning of splits is turned on, this only affects the first   write, where there is no history to learn record sizes from.
hoodie.compact.schedule.inline	false	When set to true, compaction service will be attempted for inline scheduling after each write. Users have to ensure they have a separate job to run async compaction(execution) for the one scheduled by this writer. Users can choose to set both  and  to false and have both scheduling and execution triggered by any async process. But if  is set to false, and  is set to true, regular writers will schedule compaction inline, but users are expected to trigger async job for execution. If  is set to true, regular writers will do both scheduling and execution inline for compaction
hoodie.compaction.daybased.target.partitions	10	Used by org.apache.hudi.io.compact.strategy.DayBasedCompactionStrategy to denote the number of latest partitions to compact during a compaction run.
hoodie.compact.inline	false	When set to true, compaction service is triggered after each write. While being  simpler operationally, this adds extra latency on the write path.
hoodie.filesystem.view.remote.retry.exceptions	(Optional)	The class name of the Exception that needs to be re-tryed, separated by commas. Default is empty which means retry all the IOException and RuntimeException from Remote Request.
hoodie.filesystem.view.remote.retry.initial_interval_ms	100	Amount of time (in ms) to wait, before retry to do operations on storage.
hoodie.filesystem.view.spillable.replaced.mem.fraction	0.01	Fraction of the file system view memory, to be used for holding replace commit related metadata.
hoodie.filesystem.view.spillable.dir	/tmp/	Path on local storage to use, when file system view is held in a spillable map.
hoodie.filesystem.remote.backup.view.enable	true	Config to control whether backup needs to be configured if clients were not able to reach timeline service.
hoodie.filesystem.view.spillable.compaction.mem.fraction	0.8	Fraction of the file system view memory, to be used for holding compaction related metadata.
hoodie.filesystem.view.remote.retry.max_numbers	3	Maximum number of retry for API requests against a remote file system view. e.g timeline server.
hoodie.filesystem.view.spillable.mem	104857600	Amount of memory to be used in bytes for holding file system view, before spilling to disk.
hoodie.filesystem.view.secondary.type	MEMORY	Specifies the secondary form of storage for file system view, if the primary (e.g timeline server)  is unavailable.
hoodie.filesystem.view.remote.retry.enable	false	Whether to enable API request retry for remote file system view.
hoodie.filesystem.view.remote.host	localhost	We expect this to be rarely hand configured.
hoodie.filesystem.view.remote.retry.max_interval_ms	2000	Maximum amount of time (in ms), to wait for next retry.
hoodie.filesystem.view.type	MEMORY	File system view provides APIs for viewing the files on the underlying lake storage,  as file groups and file slices. This config controls how such a view is held. Options include MEMORY,SPILLABLE_DISK,EMBEDDED_KV_STORE,REMOTE_ONLY,REMOTE_FIRST which provide different trade offs for memory usage and API request performance.
hoodie.filesystem.view.remote.timeout.secs	300	Timeout in seconds, to wait for API requests against a remote file system view. e.g timeline server.
hoodie.filesystem.view.remote.port	26754	Port to serve file system view queries, when remote. We expect this to be rarely hand configured.
hoodie.filesystem.view.spillable.bootstrap.base.file.mem.fraction	0.05	Fraction of the file system view memory, to be used for holding mapping to bootstrap base files.
hoodie.filesystem.view.spillable.clustering.mem.fraction	0.01	Fraction of the file system view memory, to be used for holding clustering related metadata.
hoodie.filesystem.view.rocksdb.base.path	/tmp/hoodie_timeline_rocksdb	Path on local storage to use, when storing file system view in embedded kv store/rocksdb.
hoodie.filesystem.view.incr.timeline.sync.enable	false	Controls whether or not, the file system view is incrementally updated as new actions are performed on the timeline.
hoodie.index.bloom.num_entries	60000	Only applies if index type is BLOOM. This is the number of entries to be stored in the bloom filter. The rationale for the default: Assume the maxParquetFileSize is 128MB and averageRecordSize is 1kb and hence we approx a total of 130K records in a file. The default (60000) is roughly half of this approximation. Warning: Setting this very low, will generate a lot of false positives and index lookup will have to scan a lot more files than it has to and setting this to a very high number will increase the size every base file linearly (roughly 4KB for every 50000 entries). This config is also used with DYNAMIC bloom filter which determines the initial size for the bloom.
hoodie.bloom.index.keys.per.bucket	10000000	Only applies if bloomIndexBucketizedChecking is enabled and index type is bloom. This configuration controls the âbucketâ size which tracks the number of record-key checks made against a single file and is the unit of work allocated to each partition performing bloom filter lookup. A higher value would amortize the fixed cost of reading a bloom filter to memory.
hoodie.simple.index.input.storage.level	MEMORY_AND_DISK_SER	Only applies when #simpleIndexUseCaching is set. Determine what level of persistence is used to cache input RDDs. Refer to org.apache.spark.storage.StorageLevel for different values
hoodie.simple.index.parallelism	100	Only applies if index type is SIMPLE. This is the amount of parallelism for index lookup, which involves a Spark Shuffle
hoodie.global.simple.index.parallelism	100	Only applies if index type is GLOBAL_SIMPLE. This is the amount of parallelism for index lookup, which involves a Spark Shuffle
hoodie.simple.index.update.partition.path	true	Similar to Key: 'hoodie.bloom.index.update.partition.path' , default: true description: Only applies if index type is GLOBAL_BLOOM. When set to true, an update including the partition path of a record that already exists will result in inserting the incoming record into the new partition and deleting the original record in the old partition. When set to false, the original record will only be updated in the old partition since version: version is not defined deprecated after: version is not defined), but for simple index.
hoodie.bucket.index.num.buckets	256	Only applies if index type is BUCKET. Determine the number of buckets in the hudi table, and each partition is divided to N buckets.
hoodie.bucket.index.hash.field	N/A	Index key. It is used to index the record and find its file group. If not set, use record key field as default
hoodie.bloom.index.use.metadata	false	Only applies if index type is BLOOM.When true, the index lookup uses bloom filters and column stats from metadata table when available to speed up the process.
hoodie.bloom.index.bucketized.checking	true	Only applies if index type is BLOOM. When true, bucketized bloom filtering is enabled. This reduces skew seen in sort based bloom index lookup
hoodie.index.type	N/A	Type of index to use. Default is SIMPLE on Spark engine and INMEMORY on Flink and Java engines. Possible options are [BLOOM | GLOBAL_BLOOM |SIMPLE | GLOBAL_SIMPLE | INMEMORY | HBASE | BUCKET]. Bloom filters removes the dependency on a external system and is stored in the footer of the Parquet Data Files
hoodie.index.bloom.fpp	0.000000001	Only applies if index type is BLOOM. Error rate allowed given the number of entries. This is used to calculate how many bits should be assigned for the bloom filter and the number of hash functions. This is usually set very low (default: 0.000000001), we like to tradeoff disk space for lower false positives. If the number of entries added to bloom filter exceeds the configured value (hoodie.index.bloom.num_entries), then this fpp may not be honored.
hoodie.bloom.index.update.partition.path	true	Only applies if index type is GLOBAL_BLOOM. When set to true, an update including the partition path of a record that already exists will result in inserting the incoming record into the new partition and deleting the original record in the old partition. When set to false, the original record will only be updated in the old partition
hoodie.bloom.index.use.caching	true	Only applies if index type is BLOOM.When true, the input RDD will cached to speed up index lookup by reducing IO for computing parallelism or affected partitions
hoodie.bloom.index.input.storage.level	MEMORY_AND_DISK_SER	Only applies when #bloomIndexUseCaching is set. Determine what level of persistence is used to cache input RDDs. Refer to org.apache.spark.storage.StorageLevel for different values
hoodie.bloom.index.use.treebased.filter	true	Only applies if index type is BLOOM. When true, interval tree based file pruning optimization is enabled. This mode speeds-up file-pruning based on key ranges when compared with the brute-force mode
hoodie.bloom.index.parallelism	0	Only applies if index type is BLOOM. This is the amount of parallelism for index lookup, which involves a shuffle. By default, this is auto computed based on input workload characteristics.
hoodie.index.bucket.engine	SIMPLE	Type of bucket index engine to use. Default is SIMPLE bucket index, with fixed number of bucket.Possible options are [SIMPLE | CONSISTENT_HASHING].Consistent hashing supports dynamic resizing of the number of bucket, solving potential data skew and file size issues of the SIMPLE hashing engine.
hoodie.bloom.index.filter.dynamic.max.entries	100000	The threshold for the maximum number of keys to record in a dynamic Bloom filter row. Only applies if filter type is BloomFilterTypeCode.DYNAMIC_V0.
hoodie.simple.index.use.caching	true	Only applies if index type is SIMPLE. When true, the incoming writes will cached to speed up index lookup by reducing IO for computing parallelism or affected partitions
hoodie.bloom.index.prune.by.ranges	true	Only applies if index type is BLOOM. When true, range information from files to leveraged speed up index lookups. Particularly helpful, if the key has a monotonously increasing prefix, such as timestamp. If the record key is completely random, it is better to turn this off, since range pruning will only  add extra overhead to the index lookup.
hoodie.bloom.index.filter.type	DYNAMIC_V0	Filter type used. Default is BloomFilterTypeCode.DYNAMIC_V0. Available values are [BloomFilterTypeCode.SIMPLE , BloomFilterTypeCode.DYNAMIC_V0]. Dynamic bloom filters auto size themselves based on number of keys.
hoodie.index.class	(Optional)	Full path of user-defined index class and must be a subclass of HoodieIndex class. It will take precedence over the hoodie.index.type configuration if specified
hoodie.clustering.plan.strategy.cluster.end.partition	N/A	End partition used to filter partition (inclusive), only effective when the filter mode 'hoodie.clustering.plan.partition.filter.mode' is SELECTED_PARTITIONS
hoodie.clustering.rollback.pending.replacecommit.on.conflict	false	If updates are allowed to file groups pending clustering, then set this config to rollback failed or pending clustering instants. Pending clustering will be rolled back ONLY IF there is conflict between incoming upsert and filegroup to be clustered. Please exercise caution while setting this config, especially when clustering is done very frequently. This could lead to race condition in rare scenarios, for example, when the clustering completes after instants are fetched but before rollback completed.
hoodie.clustering.async.max.commits	4	Config to control frequency of async clustering
hoodie.clustering.inline.max.commits	4	Config to control frequency of clustering planning
hoodie.layout.optimize.enable	false	This setting has no effect. Please refer to clustering configuration, as well as LAYOUT_OPTIMIZE_STRATEGY config to enable advanced record layout optimization strategies
hoodie.clustering.plan.strategy.target.file.max.bytes	1073741824	Each group can produce 'N' (CLUSTERING_MAX_GROUP_SIZE/CLUSTERING_TARGET_FILE_SIZE) output file groups
hoodie.clustering.plan.strategy.daybased.skipfromlatest.partitions	0	Number of partitions to skip from latest when choosing partitions to create ClusteringPlan
hoodie.clustering.execution.strategy.class	org.apache.hudi.client.clustering.run.strategy.SparkSortAndSizeExecutionStrategy	Config to provide a strategy class (subclass of RunClusteringStrategy) to define how the  clustering plan is executed. By default, we sort the file groups in th plan by the specified columns, while  meeting the configured target file sizes.
hoodie.clustering.async.enabled	false	Enable running of clustering service, asynchronously as inserts happen on the table.
hoodie.clustering.plan.strategy.class	org.apache.hudi.client.clustering.plan.strategy.SparkSizeBasedClusteringPlanStrategy	Config to provide a strategy class (subclass of ClusteringPlanStrategy) to create clustering plan i.e select what file groups are being clustered. Default strategy, looks at the clustering small file size limit (determined by hoodie.clustering.plan.strategy.small.file.limit) to pick the small file slices within partitions for clustering.
hoodie.layout.optimize.build.curve.sample.size	200000	Determines target sample size used by the Boundary-based Interleaved Index method of building space-filling curve. Larger sample size entails better layout optimization outcomes, at the expense of higher memory footprint.
hoodie.clustering.plan.strategy.partition.selected	N/A	Partitions to run clustering
hoodie.clustering.updates.strategy	org.apache.hudi.client.clustering.update.strategy.SparkRejectUpdateStrategy	Determines how to handle updates, deletes to file groups that are under clustering. Default strategy just rejects the update
hoodie.layout.optimize.strategy	linear	Determines ordering strategy used in records layout optimization. Currently supported strategies are "linear", "z-order" and "hilbert" values are supported.
hoodie.clustering.inline	false	Turn on inline clustering - clustering will be run after each write operation is complete
hoodie.clustering.plan.strategy.cluster.begin.partition	N/A	Begin partition used to filter partition (inclusive), only effective when the filter mode 'hoodie.clustering.plan.partition.filter.mode' is SELECTED_PARTITIONS
hoodie.clustering.plan.strategy.sort.columns	N/A	Columns to sort the data by when clustering
hoodie.clustering.preserve.commit.metadata	true	When rewriting data, preserves existing hoodie_commit_time
hoodie.clustering.plan.strategy.max.num.groups	30	Maximum number of groups to create as part of ClusteringPlan. Increasing groups will increase parallelism
hoodie.clustering.plan.partition.filter.mode	NONE	Partition filter mode used in the creation of clustering plan. Available values are - NONE: do not filter table partition and thus the clustering plan will include all partitions that have clustering candidate.RECENT_DAYS: keep a continuous range of partitions, worked together with configs 'hoodie.clustering.plan.strategy.daybased.lookback.partitions' and 'hoodie.clustering.plan.strategy.daybased.skipfromlatest.partitions.SELECTED_PARTITIONS: keep partitions that are in the specified range ['hoodie.clustering.plan.strategy.cluster.begin.partition', 'hoodie.clustering.plan.strategy.cluster.end.partition'].
hoodie.clustering.schedule.inline	false	When set to true, clustering service will be attempted for inline scheduling after each write. Users have to ensure they have a separate job to run async clustering(execution) for the one scheduled by this writer. Users can choose to set both  and  to false and have both scheduling and execution triggered by any async process, on which case  is expected to be set to true. But if  is set to false, and  is set to true, regular writers will schedule clustering inline, but users are expected to trigger async job for execution. If  is set to true, regular writers will do both scheduling and execution inline for clustering
hoodie.layout.optimize.data.skipping.enable	true	Enable data skipping by collecting statistics once layout optimization is complete.
hoodie.clustering.plan.strategy.max.bytes.per.group	2147483648	Each clustering operation can create multiple output file groups. Total amount of data processed by clustering operation is defined by below two properties (CLUSTERING_MAX_BYTES_PER_GROUP * CLUSTERING_MAX_NUM_GROUPS). Max amount of data to be included in one group
hoodie.clustering.plan.strategy.small.file.limit	314572800	Files smaller than the size in bytes specified here are candidates for clustering
hoodie.layout.optimize.curve.build.method	direct	Controls how data is sampled to build the space-filling curves. Two methods: "direct", "sample". The direct method is faster than the sampling, however sample method would produce a better data layout.
hoodie.clustering.plan.strategy.partition.regex.pattern	N/A	Filter clustering partitions that matched regex pattern
hoodie.clustering.plan.strategy.daybased.lookback.partitions	2	Number of partitions to list to create ClusteringPlan
hoodie.common.diskmap.compression.enabled	true	Turn on compression for BITCASK disk map used by the External Spillable Map
hoodie.datasource.write.reconcile.schema	false	When a new batch of write has records with old schema, but latest table schema got evolved, this config will upgrade the records to leverage latest table schema(default values will be injected to missing fields). If not, the write batch would fail.
hoodie.common.spillable.diskmap.type	BITCASK	When handling input data that cannot be held in memory, to merge with a file on storage, a spillable diskmap is employed.  By default, we use a persistent hashmap based loosely on bitcask, that offers O(1) inserts, lookups. Change this to  to prefer using rocksDB, for handling the spill.
hoodie.schema.on.read.enable	false	Enables support for Schema Evolution feature
hoodie.bootstrap.partitionpath.translator.class	org.apache.hudi.client.bootstrap.translator.IdentityBootstrapPartitionPathTranslator	Translates the partition paths from the bootstrapped data into how is laid out as a Hudi table.
hoodie.bootstrap.full.input.provider	org.apache.hudi.bootstrap.SparkParquetBootstrapDataProvider	Class to use for reading the bootstrap dataset partitions/files, for Bootstrap mode FULL_RECORD
hoodie.bootstrap.keygen.type	SIMPLE	Type of build-in key generator, currently support SIMPLE, COMPLEX, TIMESTAMP, CUSTOM, NON_PARTITION, GLOBAL_DELETE
hoodie.bootstrap.keygen.class	N/A	Key generator implementation to be used for generating keys from the bootstrapped dataset
hoodie.bootstrap.parallelism	1500	Parallelism value to be used to bootstrap data into hudi
hoodie.bootstrap.base.path	N/A	Base path of the dataset that needs to be bootstrapped as a Hudi table
hoodie.bootstrap.mode.selector.regex	.*	Matches each bootstrap dataset partition against this regex and applies the mode below to it.
hoodie.bootstrap.index.class	org.apache.hudi.common.bootstrap.index.HFileBootstrapIndex	Implementation to use, for mapping a skeleton base file to a boostrap base file.
hoodie.bootstrap.mode.selector.regex.mode	METADATA_ONLY	Bootstrap mode to apply for partition paths, that match regex above. METADATA_ONLY will generate just skeleton base files with keys/footers, avoiding full cost of rewriting the dataset. FULL_RECORD will perform a full copy/rewrite of the data as a Hudi table.
hoodie.bootstrap.mode.selector	org.apache.hudi.client.bootstrap.selector.MetadataOnlyBootstrapModeSelector	Selects the mode in which each file/partition in the bootstrapped dataset gets bootstrapped
hoodie.metrics.datadog.api.timeout.seconds	3	Datadog API timeout in seconds. Default to 3.
hoodie.metrics.datadog.metric.prefix	N/A	Datadog metric prefix to be prepended to each metric name with a dot as delimiter. For example, if it is set to foo, foo. will be prepended.
hoodie.metrics.datadog.api.site	N/A	Datadog API site: EU or US
hoodie.metrics.datadog.api.key.skip.validation	false	Before sending metrics via Datadog API, whether to skip validating Datadog API key or not. Default to false.
hoodie.metrics.datadog.metric.host	N/A	Datadog metric host to be sent along with metrics data.
hoodie.metrics.datadog.report.period.seconds	30	Datadog reporting period in seconds. Default to 30.
hoodie.metrics.datadog.api.key	N/A	Datadog API key
hoodie.metrics.datadog.api.key.supplier	N/A	Datadog API key supplier to supply the API key at runtime. This will take effect if hoodie.metrics.datadog.api.key is not set.
hoodie.metrics.datadog.metric.tags	N/A	Datadog metric tags (comma-delimited) to be sent along with metrics data.
hoodie.metrics.cloudwatch.report.period.seconds	60	Reporting interval in seconds
hoodie.metrics.cloudwatch.namespace	Hudi	Namespace of reporter
hoodie.metrics.cloudwatch.metric.prefix	(Optional)	Metric prefix of reporter
hoodie.metrics.cloudwatch.maxDatumsPerRequest	20	Max number of Datums per request
hoodie.metrics.executor.enable  N/A
hoodie.metrics.reporter.metricsname.prefix	(Optional)	The prefix given to the metrics names.
hoodie.metrics.reporter.type	GRAPHITE	Type of metrics reporter.
hoodie.metrics.reporter.class
hoodie.metrics.on	false	Turn on/off metrics reporting. off by default.
hoodie.metrics.jmx.host	localhost	Jmx host to connect to
hoodie.metrics.jmx.port	9889	Jmx port to connect to
hoodie.metrics.pushgateway.random.job.name.suffix	true	Whether the pushgateway name need a random suffix , default true.
hoodie.metrics.pushgateway.port	9091	Port for the push gateway.
hoodie.metrics.pushgateway.delete.on.shutdown	true	Delete the pushgateway info or not when job shutdown, true by default.
hoodie.metrics.prometheus.port	9090	Port for prometheus server.
hoodie.metrics.pushgateway.job.name	(Optional)	Name of the push gateway job.
hoodie.metrics.pushgateway.report.period.seconds	30	Reporting interval in seconds.
hoodie.metrics.pushgateway.host	localhost	Hostname of the prometheus push gateway.
hoodie.metrics.graphite.port	4756	Graphite port to connect to.
hoodie.metrics.graphite.report.period.seconds	30	Graphite reporting period in seconds. Default to 30.
hoodie.metrics.graphite.host	localhost	Graphite host to connect to.
hoodie.metrics.graphite.metric.prefix	N/A	Standard prefix applied to all metrics. This helps to add datacenter, environment information for e.g
hoodie.compaction.payload.class	org.apache.hudi.common.model.OverwriteWithLatestAvroPayload	This needs to be same as class used during insert/upserts. Just like writing, compaction also uses the record payload class to merge records in the log against each other, merge again with the base file and produce the final record to be written after compaction.
hoodie.payload.event.time.field	ts	Table column/field name to derive timestamp associated with the records. This canbe useful for e.g, determining the freshness of the table.
hoodie.payload.ordering.field	ts	Table column/field name to order records that have the same key, before merging and writing to storage.
hoodie.kafka.coordinator.write.timeout.secs	300	The timeout after sending an END_COMMIT until when the coordinator will wait for the write statuses from all the partitionsto ignore the current commit and start a new commit.
hoodie.meta.sync.classes	org.apache.hudi.hive.HiveSyncTool	Meta sync client tool, using comma to separate multi tools
hoodie.kafka.allow.commit.on.errors	true	Commit even when some records failed to be written
hadoop.home	N/A	The Hadoop home directory.
hoodie.meta.sync.enable	false	Enable Meta Sync such as Hive
hoodie.kafka.commit.interval.secs	60	The interval at which Hudi will commit the records written to the files, making them consumable on the read-side.
hoodie.kafka.control.topic	hudi-control-topic	Kafka topic name used by the Hudi Sink Connector for sending and receiving control messages. Not used for data records.
bootstrap.servers	localhost:9092	The bootstrap servers for the Kafka Cluster.
hoodie.schemaprovider.class	org.apache.hudi.schema.FilebasedSchemaProvider	subclass of org.apache.hudi.schema.SchemaProvider to attach schemas to input & target table data, built in options: org.apache.hudi.schema.FilebasedSchemaProvider.
hadoop.conf.dir	N/A	The Hadoop configuration directory.
hoodie.kafka.compaction.async.enable	true	Controls whether async compaction should be turned on for MOR table writing.
hoodie.aws.session.token	N/A	AWS session token
hoodie.aws.access.key	N/A	AWS access key id
hoodie.aws.secret.key	N/A	AWS secret key
